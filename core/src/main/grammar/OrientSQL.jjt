/*
  *
  *  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)
  *  *
  *  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  *  you may not use this file except in compliance with the License.
  *  *  You may obtain a copy of the License at
  *  *
  *  *       http://www.apache.org/licenses/LICENSE-2.0
  *  *
  *  *  Unless required by applicable law or agreed to in writing, software
  *  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  *  See the License for the specific language governing permissions and
  *  *  limitations under the License.
  *  *
  *  * For more information: http://www.orientechnologies.com
  *
  */


options {
	TRACK_TOKENS = true;
  	JDK_VERSION = "1.5";
  	MULTI=true;
  	VISITOR=true;
  	STATIC=false;
  	NODE_PREFIX="O";
}

PARSER_BEGIN(OrientSql)

package com.orientechnologies.orient.core.sql.parser;

/** Orient Database Sql grammar. */
public class OrientSql {

    /** Main entry point. For development purpose only */
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    OrientSql t = new OrientSql(System.in);
    try {
      SimpleNode n = t.OrientGrammar();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

}

PARSER_END(OrientSql)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}



/* reserved words */
TOKEN:
{
	< SELECT: ( "s" | "S" ) ( "e" | "E" ) ( "l" | "L" ) ( "e" | "E" ) ( "c" | "C" ) ( "t" | "T" ) >
	|
	< TRAVERSE: ( "t" | "T") ( "r" | "R") ( "a" | "A") ( "v" | "V") ( "e" | "E") ( "r" | "R") ( "s" | "S") ( "e" | "E") >
	|
	< INSERT: ( "i" | "I" ) ( "n" | "N" ) ( "s" | "S" ) ( "e" | "E" ) ( "r" | "R" ) ( "t" | "T" ) >
	|
	< UPDATE: ( "u" | "U" ) ( "p" | "P" ) ( "d" | "D" ) ( "a" | "A" ) ( "t" | "T" ) ( "e" | "E" ) >
	|
	< DELETE: ( "d" | "D" ) ( "e" | "E" ) ( "l" | "L" ) ( "e" | "E" ) ( "t" | "T" ) ( "e" | "E" ) >
	|
	< FROM: ( "f" | "F" ) ( "r" | "R" ) ( "o" | "O" ) ( "m" | "M" ) >
	|
	< WHERE: ( "w" | "W" ) ( "h" | "H" ) ( "e" | "E" ) ( "r" | "R" ) ( "e" | "E" ) >
	|
	< WHILE: ( "w" | "W" ) ( "h" | "H" ) ( "i" | "I" ) ( "l" | "L" ) ( "e" | "E" ) >
	|
	< INTO: ( "i" | "I" ) ( "n" | "N" ) ( "t" | "T" ) ( "o" | "O" ) >
	|
	< VALUES: ( "v" | "V" ) ( "a" | "A" ) ( "l" | "L" ) ( "u" | "U" ) ( "e" | "E" ) ( "s" | "S" )>
	|
	< SET: ( "s" | "S" ) ( "e" | "E" ) ( "t" | "T" ) >
	|
	< ADD: ( "a" | "A" ) ( "d" | "D" ) ( "d" | "D" ) >
	|
	< REMOVE: ( "r" | "R" ) ( "e" | "E" ) ( "m" | "M" ) ( "o" | "O" ) ( "v" | "V" ) ( "e" | "E" ) >
	|
	< AND: ( "a" | "A" ) ( "n" | "N" ) ( "d" | "D" ) >
	|
	< OR: ( "o" | "O" ) ( "r" | "R" ) >
	|
	< NULL: ( "N" | "n" ) ( "U" | "u" ) ( "L" | "l" ) ( "L" | "l" ) >
	|
	< ORDER: ( "o" | "O" ) ( "r" | "R" ) ( "d" | "D" ) ( "e" | "E" ) ( "r" | "R" ) >
	|
	< GROUP: ( "g" | "G" ) ( "r" | "R" ) ( "o" | "O" ) ( "u" | "U" ) ( "p" | "P" ) >
	|
	< BY: ( "b" | "B" ) ( "y" | "Y" ) >
	|
	< LIMIT: ( "l" | "L" ) ( "i" | "I" ) ( "m" | "M" ) ( "i" | "I" ) ( "t" | "T" ) >
	|
	< SKIP2: ( "s" | "S" ) ( "k" | "K" ) ( "i" | "I" ) ( "p" | "P" ) >
	|
	< ASC: ( "a" | "A" ) ( "s" | "S" ) ( "c" | "C" ) >
	|
	< AS: ( "a" | "A" ) ( "s" | "S" ) >
	|
	< DESC: ( "d" | "D" ) ( "e" | "E" ) ( "s" | "S" ) ( "c" | "C" ) >
	|
	< THIS: "@this" >
	|
	< RECORD_ATTRIBUTE: <RID_ATTR> | <CLASS_ATTR> | <VERSION_ATTR> | <SIZE_ATTR> | <TYPE_ATTR> >
	|
	< #RID_ATTR: "@rid" >
	|
	< #CLASS_ATTR: "@class" >
	|
	< #VERSION_ATTR: "@version" >
	|
	< #SIZE_ATTR: "@size" >
	|
	< #TYPE_ATTR: "@type" >
}


/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      (
	      "\""
	      (   (~["\"","\\","\n","\r"])
	        | ("\\"
	            ( ["n","t","b","r","f","\\","'","\""]
	            | ["0"-"7"] ( ["0"-"7"] )?
	            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
	            )
	          )
	      )*
	      "\""
      )
      |
      (
	      "'"
	      (   (~["\'","\\","\n","\r"])
	        | ("\\"
	            ( ["n","t","b","r","f","\\","'","\""]
	            | ["0"-"7"] ( ["0"-"7"] )?
	            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
	            )
	          )
	      )*
	      "'"
      )
  >
}



/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{

  < EQ: "=" >
| < LT: "<" >
| < GT: ">" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < NEQ: "<>" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < NOT: ( "N" | "n") ( "O" | "o") ( "T" | "t")  >
| < IN: ( "I" | "i") ( "N" | "n") >
| < LIKE: ( "L" | "l") ( "I" | "i") ( "K" | "k") ( "E" | "e") >
| < IS: "is" | "IS" | "Is" | "iS" >
| < BETWEEN: ( "B" | "b") ( "E" | "e") ( "T" | "t") ( "W" | "w") ( "E" | "e") ( "E" | "e") ( "N" | "n")>
| < CONTAINS: ( "C" | "c" ) ( "O" | "o" ) ( "N" | "n" ) ( "T" | "t" ) ( "A" | "a" ) ( "I" | "i" ) ( "N" | "n" ) ( "S" | "s" ) >
| < CONTAINSALL: ( "C" | "c" ) ( "O" | "o" ) ( "N" | "n" ) ( "T" | "t" ) ( "A" | "a" ) ( "I" | "i" ) ( "N" | "n" ) ( "S" | "s" ) ( "A" | "a" ) ( "L" | "l" ) ( "L" | "l" ) >
| < CONTAINSKEY: ( "C" | "c" ) ( "O" | "o" ) ( "N" | "n" ) ( "T" | "t" ) ( "A" | "a" ) ( "I" | "i" ) ( "N" | "n" ) ( "S" | "s" ) ( "K" | "k" ) ( "E" | "e" ) ( "Y" | "y" ) >
| < CONTAINSVALUE: ( "C" | "c" ) ( "O" | "o" ) ( "N" | "n" ) ( "T" | "t" ) ( "A" | "a" ) ( "I" | "i" ) ( "N" | "n" ) ( "S" | "s" ) ( "V" | "v" ) ( "A" | "a" ) ( "L" | "l" ) ( "U" | "u" ) ( "E" | "e" ) >
| < CONTAINSTEXT: ( "C" | "c" ) ( "O" | "o" ) ( "N" | "n" ) ( "T" | "t" ) ( "A" | "a" ) ( "I" | "i" ) ( "N" | "n" ) ( "S" | "s" ) ( "T" | "t" ) ( "E" | "e" ) ( "X" | "x" ) ( "T" | "t" ) >
| < MATCHES: ( "M" | "m") ( "A" | "a") ( "T" | "t") ( "C" | "c") ( "H" | "h") ( "E" | "e") ( "S" | "s") >
}



TOKEN :
{
  < IDENTIFIER: ( <LETTER> (<PART_LETTER>)* ) >
|
  < #LETTER:
      [  "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
|
  < #PART_LETTER:
      [  "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
}

void Rid():
{}
{
	 LOOKAHEAD(4)
	 "#" <INTEGER_LITERAL> <COLON> <INTEGER_LITERAL>
	 |
	 LOOKAHEAD(3)
	 <INTEGER_LITERAL> <COLON> <INTEGER_LITERAL>
}

/** Root production. */
SimpleNode OrientGrammar() :
{}
{
  Statement() <EOF>
  { return jjtThis; }
}

void Identifier():
{}
{
    <IDENTIFIER> | <IN>
}


void Statement():
{}
{
	(
		SelectStatement()
		|
		TraverseStatement()
        |
		DeleteStatement()
		|
		InsertStatement()
		|
		UpdateStatement()
	)
}


void SelectStatement():
{}
{
	<SELECT>
	[ Projection() ]
	<FROM>
	FromClause()
	[ <WHERE> WhereClause() ]
	[ OrderBy() ]
	[ GroupBy() ]
	[ Skip() ]
	[ Limit() ]
}

void TraverseStatement():
{}
{
	<TRAVERSE>
	[ Projection() ]
	<FROM>
	FromClause()
	[ <WHILE> WhereClause() ]
}


void DeleteStatement():
{}
{
	<DELETE>
	<FROM>
	Identifier()
	[ <WHERE> WhereClause() ]
}

void UpdateStatement():
{}
{
	<UPDATE>
	(
		Identifier()
		|
		Cluster()
		|
		IndexIdentifier()
	)
	(
		( <SET> UpdateItem() ( "," UpdateItem() )* )
	)
	[ <WHERE> WhereClause() ]
}

void UpdateItem():
{}
{
	Identifier() <EQ>
	(
		<NULL>
		|
		<STRING_LITERAL>
		|
		LOOKAHEAD(Rid())
		Rid()
		|
		LOOKAHEAD(2)
		<INTEGER_LITERAL>
		|
		<FLOATING_POINT_LITERAL>
		|
		<CHARACTER_LITERAL>
		|
		<LBRACKET> Rid() ("," Rid())* <RBRACKET>
	)

}

void UpdateAddItem():
{}
{
	Identifier() <EQ>
	(
		<STRING_LITERAL>
		|
		LOOKAHEAD(Rid())
		Rid()
		|
		LOOKAHEAD(2)
		<INTEGER_LITERAL>
		|
		<FLOATING_POINT_LITERAL>
		|
		<CHARACTER_LITERAL>
		|
		<LBRACKET> Rid() ("," Rid())* <RBRACKET>
	)

}


void InsertStatement():
{}
{
	<INSERT>
	<INTO>
	( Identifier() | Cluster() )
	<LPAREN> Identifier() ("," Identifier()) <RPAREN>
	<VALUES>
	<LPAREN> InsertExpression() ("," InsertExpression()) <RPAREN>
}

void InsertExpression():
{}
{
	<NULL>
	|
	<STRING_LITERAL>
	|
	LOOKAHEAD(2)
	<INTEGER_LITERAL>
	|
	<FLOATING_POINT_LITERAL>
	|
	LOOKAHEAD(Rid())
	Rid()
	|
	<CHARACTER_LITERAL>
	|
	<LBRACKET> Rid() ("," Rid())* <RBRACKET>
}

void InputParameter():
{}
{
	PositionalParameter()
	|
	NamedParameter()
}

void PositionalParameter():
{}
{
	<HOOK>
}

void NamedParameter():
{}
{
	<COLON> Identifier()
}

void Projection():
{}
{
	 	ProjectionItem()  ( "," ProjectionItem() )*
}

void ProjectionItem():
{}
{
	"*"
	|
	(
		(

			<NULL>
			|
			<INTEGER_LITERAL>
			|
			<STRING_LITERAL>
			|
			<FLOATING_POINT_LITERAL>
			|
			<CHARACTER_LITERAL>
			|
			LOOKAHEAD( InputParameter() )
			InputParameter()
			|
			OperationChain()
		)
		[<AS> Alias() ]
	)
}

void FilterItem():
{}
{
	<NULL>
	|
	Any()
	|
	All()
	|
	<INTEGER_LITERAL>
	|
	<STRING_LITERAL>
	|
	<FLOATING_POINT_LITERAL>
	|
	<CHARACTER_LITERAL>
	|
	LOOKAHEAD( InputParameter() )
    InputParameter()
    |
    LOOKAHEAD( OperationChain() )
	OperationChain()
}

void Alias():
{}
{
	Identifier()
}

void Any():
{}
{
	"any()"
}

void All():
{}
{
	"all()"
}

void RecordAttribute():
{}
{
	<RECORD_ATTRIBUTE>
}

void ThisOperation():
{}
{
	<THIS> ( MethodCall() )*
}

void FunctionCall():
{}
{
	Identifier()
	<LPAREN>

	(
		"*"
		|
		(
			FilterItem()
			( "," FilterItem() )*
		)
	)
	<RPAREN>
}

void MethodCall():
{}
{
	( <DOT> Identifier() <LPAREN> [ FilterItem() ( "," FilterItem() )* ] <RPAREN> )
}

void LevelZeroIdentifier():
{}
{
    LOOKAHEAD(2)
    FunctionCall()
    |
    <THIS>
}

void SuffixIdentifier():
{}
{
    Identifier()
    |
    RecordAttribute()
}


void BaseIdentifier():
{}
{
    LOOKAHEAD( LevelZeroIdentifier() )
    LevelZeroIdentifier()
    |
    LOOKAHEAD( SuffixIdentifier() )
    SuffixIdentifier()
}

void Modifier():
{}
{

    (
        "[" OrBlock() "]"
   	    |
   	    LOOKAHEAD(3)
   	    MethodCall()
   	    |
   	    LOOKAHEAD(3)
        <DOT> SuffixIdentifier()
    )
    [ Modifier() ]
}

void OperationChain():
{}
{
	BaseIdentifier() [ Modifier() ]
}


void FromClause():
{}
{
	FromItem()
}

void FromItem():
{}
{
	Rid()
	|
	<LBRACKET> Rid() ("," Rid())* <RBRACKET>
	|
	Cluster()
	|
	IndexIdentifier()
	|
	Identifier()
	|
	<LPAREN> SelectStatement() <RPAREN>
}

void Cluster():
{}
{
	"cluster:" Identifier()
}

void IndexIdentifier():
{}
{
	"index:" Identifier()
}

void WhereClause():
{}
{
	OrBlock()
}

void OrBlock():
{}
{
	AndBlock() ( <OR> AndBlock() )*
}

void AndBlock():
{}
{
	( NotBlock() ) ( <AND> ( NotBlock() ) )*
}

void NotBlock():
{}
{
	[ <NOT> ] ( ConditionBlock() | ParenthesisBlock() )
}

void ParenthesisBlock():
{}
{
	<LPAREN> OrBlock() <RPAREN>
}

void ConditionBlock():
{}
{
	LOOKAHEAD( IsNotNullCondition() )
	IsNotNullCondition()
	|
	LOOKAHEAD( IsNullCondition() )
	IsNullCondition()
	|
	LOOKAHEAD( InCondition() )
    InCondition()
    |
    LOOKAHEAD( NotInCondition() )
    NotInCondition()
	|
	LOOKAHEAD( BinaryCondition() )
	BinaryCondition()
	|
	LOOKAHEAD( BetweenCondition() )
	BetweenCondition()
	|
	LOOKAHEAD( ContainsCondition() )
	ContainsCondition()
	|
	LOOKAHEAD( ContainsTextCondition() )
	ContainsTextCondition()
	|
	LOOKAHEAD( MatchesCondition() )
	MatchesCondition()
}

void CompareOperator():
{}
{
		EqualsCompareOperator()
      | LtOperator()
      | GtOperator()
      | NeOperator()
      | NeqOperator()
      | GeOperator()
      | LeOperator()
      | LikeOperator()
      | ContainsKeyOperator()
      | ContainsValueOperator()
}


void LtOperator():
{}
{
	<LT>
}

void GtOperator():
{}
{
	<GT>
}

void NeOperator():
{}
{
	<NE>
}

void NeqOperator():
{}
{
	<NEQ>
}

void GeOperator():
{}
{
	<GE>
}

void LeOperator():
{}
{
	<LE>
}

void LikeOperator():
{}
{
	<LIKE>
}

void ContainsKeyOperator():
{}
{
	<CONTAINSKEY>
}

void ContainsValueOperator():
{}
{
	<CONTAINSVALUE>
}

void EqualsCompareOperator():
{}
{
	<EQ>
}

void BinaryCondition():
{}
{
 	FilterItem() CompareOperator() ( LOOKAHEAD(Rid()) Rid() | LOOKAHEAD(FilterItem())  FilterItem())
}

void BetweenCondition():
{}
{
	FilterItem() <BETWEEN> FilterItem() <AND> FilterItem()
}

void IsNullCondition():
{}
{
	FilterItem() <IS> <NULL>
}

void IsNotNullCondition():
{}
{
	FilterItem() <IS> <NOT> <NULL>
}

void ContainsCondition():
{}
{
	FilterItem() <CONTAINS> <LPAREN> OrBlock() <RPAREN>
}

void InOperator():
{}
{
    <IN>
}

void InCondition():
{}
{
	FilterItem() InOperator()
	(
	    <LBRACKET> FilterItem() (<COMMA> FilterItem())* <RBRACKET>
	    |
	    <LPAREN> SelectStatement() <RPAREN>
	)
}

void NotInCondition():
{}
{
	FilterItem() <NOT> InOperator()
	(
	    <LBRACKET> FilterItem() (<COMMA> FilterItem())* <RBRACKET>
        |
        <LPAREN> SelectStatement() <RPAREN>
	)
}

void ContainsAllCondition():
{}
{
	FilterItem() <CONTAINSALL> <LPAREN> OrBlock() <RPAREN>
}

void ContainsTextCondition():
{}
{
	FilterItem() <CONTAINSTEXT> ( <STRING_LITERAL> | OperationChain() )
}

void MatchesCondition():
{}
{
	FilterItem() <MATCHES> <STRING_LITERAL>
}

void OrderBy():
{}
{
	<ORDER> <BY> Identifier() ( "," Identifier() )* [ <DESC> | <ASC> ]
}

void GroupBy():
{}
{
	<GROUP> <BY> Identifier() ( "," Identifier() )*
}

void Limit():
{}
{
	<LIMIT> <INTEGER_LITERAL>
}

void Skip():
{}
{
	<SKIP2> <INTEGER_LITERAL>
}





